#+AUTHOR: Martin Richter
#+email: martin.richter@nottingham.ac.uk
#+date: [2023-03-09 Thu 13:00-14:00]
#+STARTUP: showall inlineimages latexpreview entitiesplain hideblocks
#+OPTIONS: ^:nil toc:nil
#+OPTIONS: tex:dvipng  # HTML export with pngs rather than MathJax

* Outlook

We are going to implement the logistic map and the transfer operator for it.

Let $r \in [0, 4]$. The logisitic map is given by

$f_r : [0, 1] \to [0, 1]$

$x \mapsto r \cdot x \cdot (1-x)$

A python implementation would look like this:
#+begin_src python :session :export code
def logistic_map(r, x):
    """
    Returns the next value for the logistic map with parameter r.

    fᵣ(x) = r·x·(1 - x)

    Paramters
    ---------
    r : double
        Parameter of the logistic map, r∈[0, 4]
    x : double or ndarray
        points to evaluate fᵣ(x) at

    Returns
    -------
    fx : double or ndarray
        values of fᵣ(x)
    """
    return r * x * (1 - x)
#+end_src

#+RESULTS:

A plot of the function can be seen here:
#+begin_src python :session :exports results :results output raw
import matplotlib.pyplot as plt
import numpy as np
import functools

r = 3.54
f_r = functools.partial(logistic_map, r)

x = np.linspace(0, 1, 30)
fig, ax = plt.subplots(1, 1)
ax.set_xlabel(r"$x$")
ax.set_xlim(0, 1)
ax.set_ylim(0, 1)
ax.set_title(f"Logistic map $f_{{{r}}}$")
ax.plot(x, f_r(x), c="C0")
ax.plot([0, 1], [0, 1], c="C0", ls="--")

filename = "figures/example_logistic_map.svg"
fig.savefig(filename, transparent=True)
print(f"[[file:{filename}]]")
#+end_src

#+RESULTS:
[[file:figures/example_logistic_map.svg]]

We can use it iteratively:
#+begin_src python :session :export both :results output raw table
x_0 = 0.45
print("| iter | value |\n|---|")
for j in range(5):
    print(f"| {j: 4d} | {x_0: .7f} |")
    # update the value
    x_0 = f_r(x_0)
print("")
#+end_src

#+RESULTS:
| iter |     value |
|------+-----------|
|    0 | 0.4500000 |
|    1 | 0.8761500 |
|    2 | 0.3841296 |
|    3 | 0.8374721 |
|    4 | 0.4818385 |

** Using ~reduce~ to Iterate the Map

#+begin_src python :session
x_0 = 0.45

# You can use reduce for repeated function evaluation
orbit = np.array(functools.reduce(
    lambda result, next_item: result + [f_r(result[-1])],
    range(10), [x_0]))
#+end_src

#+RESULTS:

* Introduction to Transfer Operators

We have our map $f_r:[0, 1] \to [0, 1]$

But we want to think of densities of initial conditions. So think of a function
\(\rho \in X([0, 1])\) where we don't want to be precise about what X is (e.g. $L^1$)

What happens under one iteration of \(f_r\)? Answer is the /Frobenius-Perron operator/ $T$

A$(T\rho)(y) := \int\limits_0^1 \delta(y - f_r(x)) \rho(x)\mathrm{d}x$

One common trick: $\delta(g(x)) = \sum\limits_{x_0: g(x_0) = 0} \frac{1}{|g'(x_0)|}\delta(x - x_0)$

For us this means:
$(T\rho)(y) = \sum\limits_{x_0: f_r(x_0) = y}\int\limits_{0}^{1} \frac{1}{|f_r'(x_0)|}\delta(x - x_0)\rho(x)\mathrm{d}x$

This means:
$(T\rho)(y) = \sum\limits_{x_0: f_r(x_0) = y} \frac{1}{|f_r'(x_0)|}\rho(x_0)$

*Side Note*: If $f_r$ would be _bijective_ then we could simplify the above to:
$(T\rho)(y) = \frac{1}{|f_r'(f_r^{-1}(y))|}\rho(f_r^{-1}(y))$
Furthermore, if the mapping would be volume preserving (in other words, the Jacobian is 1), then
$(T\rho)(y) = \rho(f_r^{-1}(y)) = (\rho\circ f_r^{-1})(y)$

** TODO Transfer Operator for the Logistic Map

** TODO Implementation
